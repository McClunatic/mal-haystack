import pathlib
import zipfile
from typing import List, Optional

from haystack.nodes import BaseComponent


class ZipLister(BaseComponent):
    """Component for generating a list of file names in zip files.

    .. note::

       This expander does not consider depth and reports full paths in the zip.

    Parameters:
        id_hash_keys: Generate the document id from a custom list of strings
            that refer to the document's attributes. If you want to ensure you
            don't have duplicate documents in your DocumentStore but texts are
            not unique, you can modify the metadata and pass e.g. `"meta"` to
            this field (e.g. [`"content"`, `"meta"`]). In this case the id will
            be generated by using the content and the defined metadata.
    """

    outgoing_edges: int = 1

    def __init__(
        self,
        id_hash_keys: Optional[List[str]] = None,
    ):
        """Constructor."""

        self.id_hash_keys = id_hash_keys

    def convert(
        self,
        zip_path: str | pathlib.Path,
        valid_names: Optional[List[str]] = None,
        id_hash_keys: Optional[List[str]] = None,
    ):
        """Convert `zip_path` to a list of contained files.

        Arguments:
            zip_path: The source zip file to produce a namelist for.
            valid_names: If specified, a namelist filter to apply.
            id_hash_keys: Generate the document id from a custom list of
                strings that refer to the document's attributes. If you want to
                ensure you don't have duplicate documents in your DocumentStore
                but texts are not unique, you can modify the metadata and pass
                e.g. `"meta"` to this field (e.g. [`"content"`, `"meta"`]). In
                this case the id will be generated by using the content and the
                defined metadata.
        """

        if id_hash_keys is None:
            id_hash_keys = self.id_hash_keys

        with zipfile.ZipFile(zip_path) as myzip:
            namelist = myzip.namelist()

        if valid_names is not None:
            namelist = [name for name in namelist if name in valid_names]

        return namelist

    def run(
        self,
        file_paths: List[str | pathlib.Path],
        valid_names: Optional[List[str]] = None,
        id_hash_keys: Optional[List[str]] = None,
    ):
        """Extract contained filenames from `zip_path`.

        Arguments:
            zip_path: The source zip file to produce a namelist for.
            valid_names: If specified, a namelist filter to apply.
            id_hash_keys: Generate the document id from a custom list of
                strings that refer to the document's attributes. If you want to
                ensure you don't have duplicate documents in your DocumentStore
                but texts are not unique, you can modify the metadata and pass
                e.g. `"meta"` to this field (e.g. [`"content"`, `"meta"`]). In
                this case the id will be generated by using the content and the
                defined metadata.
        """

        # Convert series into documents
        namelist = []
        zip_path_list = []
        for zip_path in file_paths:
            nl = self.convert(
                zip_path,
                valid_names=valid_names,
                id_hash_keys=id_hash_keys,
            )

            zp_list = [zip_path] * len(nl)
            namelist.extend(nl)
            zip_path_list.extend(zp_list)

        result = {'file_paths': namelist, 'meta': {'zip_paths': zip_path_list}}
        return result, 'output_1'

    run_batch = run
